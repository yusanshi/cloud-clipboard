<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cloud Clipboard</title>

    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css"
    />
    <style>
      .container {
        max-width: 900px;
      }
      img {
        max-width: 100%;
        max-height: 400px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .collapsing {
        transition: height 0.25s ease;
      }
    </style>
  </head>

  <body>
    <div class="container my-md-5">
      <div class="bg-primary-subtle rounded p-4 my-4">
        <div class="mb-3">
          <h3>Cloud</h3>
        </div>
        <div id="cloud" class="text-center"></div>
        <div
          id="progressBar"
          class="progress mt-4 d-none"
          role="progressbar"
          aria-valuemin="0"
          aria-valuemax="100"
        >
          <div id="progressBarInner" class="progress-bar"></div>
        </div>
      </div>

      <div class="text-center">
        <div class="btn-group btn-group-lg my-2">
          <button
            type="button"
            class="btn btn-outline-primary"
            onclick="pullToLocal()"
          >
            <i class="bi-cloud-download"></i> Pull to local
          </button>
          <button
            type="button"
            class="btn btn-outline-success"
            onclick="pushToCloud()"
          >
            <i class="bi-cloud-upload"></i> Push to cloud
          </button>
        </div>
      </div>

      <div class="bg-success-subtle rounded p-4 my-4">
        <div class="mb-3">
          <h3 class="d-inline align-middle">Local</h3>
          <button
            type="button"
            class="btn btn-outline-success m-2 align-middle"
            onclick="getAndShowLocalClipboard()"
          >
            Retry/Refresh
          </button>
        </div>
        <div id="local" class="text-center"></div>
      </div>

      <br />

      <div class="mb-2">
        <label
          for="log"
          class="form-label text-decoration-underline"
          data-bs-toggle="collapse"
          href="#logCollapse"
          role="button"
          aria-expanded="false"
          aria-controls="logCollapse"
          >View log</label
        >
        <div class="collapse" id="logCollapse">
          <textarea
            class="form-control"
            rows="8"
            id="log"
            style="font-size: 0.8em"
            readonly
          ></textarea>
        </div>
      </div>

      <div class="mb-2">
        <label for="redis" class="form-label"
          ><span
            class="text-decoration-underline"
            data-bs-toggle="collapse"
            href="#redisCollapse"
            role="button"
            aria-expanded="false"
            aria-controls="redisCollapse"
          >
            View/edit Redis info</span
          >
          (<a target="_blank" href="https://github.com/nicolasff/webdis"
            >webdis</a
          >)
        </label>
        <div class="collapse" id="redisCollapse">
          <textarea
            class="form-control"
            rows="6"
            id="redis"
            style="font-size: 0.8em"
          ></textarea>
        </div>
      </div>
    </div>

    <a
      target="_blank"
      href="https://github.com/yusanshi/cloud-clipboard"
      class="github-corner"
      aria-label="View source on GitHub"
      ><svg
        width="80"
        height="80"
        viewBox="0 0 250 250"
        style="
          fill: #64ceaa;
          color: #fff;
          position: absolute;
          top: 0;
          border: 0;
          right: 0;
        "
        aria-hidden="true"
      >
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor"
          style="transform-origin: 130px 106px"
          class="octo-arm"
        ></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor"
          class="octo-body"
        ></path></svg></a
    ><style>
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
      @keyframes octocat-wave {
        0%,
        100% {
          transform: rotate(0);
        }
        20%,
        60% {
          transform: rotate(-25deg);
        }
        40%,
        80% {
          transform: rotate(10deg);
        }
      }
      @media (max-width: 500px) {
        .github-corner:hover .octo-arm {
          animation: none;
        }
        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
      }
    </style>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.2/dist/axios.min.js"></script>

    <script>
      const logContainer = document.querySelector('#log');
      const redisContainer = document.querySelector('#redis');
      function log(message) {
        const line = `[${new Date().toISOString()}] ${message}\n`;
        console.log(line);
        logContainer.value += line;
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      async function readClipboard() {
        try {
          const permission = await navigator.permissions.query({
            name: 'clipboard-read',
          });
          if (permission.state === 'denied') {
            return { type: null, data: 'No read permission for clipboard' };
          }
        } catch {
          // https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API#browser_compatibility
          log('Permission "clipboard-read" not supported');
        }

        let items;
        try {
          items = await navigator.clipboard.read();
        } catch (e) {
          return {
            type: null,
            data: `Failed to read clipboard: ${e.name} ${e.message}`,
          };
        }

        if (items.length === 0) {
          return { type: null, data: 'Clipboard empty' };
        }

        for (const [index, item] of items.entries()) {
          log(`Local clipboard item ${index}: ${item.types}`);
        }

        const item = items[0];
        if (item.types.includes('image/png')) {
          const blob = await item.getType('image/png');
          return { type: 'image', data: blob };
        } else if (item.types.includes('text/plain')) {
          const blob = await item.getType('text/plain');
          const text = await blob.text();
          return { type: 'text', data: text };
        } else {
          return {
            type: null,
            data: `Unknown clipboard MIME types: "${item.types}"`,
          };
        }
      }

      function B2KB(byte) {
        if (byte === undefined) {
          return '-';
        }
        return Math.round(byte / 1024);
      }

      function generateProgressHook(prefix) {
        const progressHook = ({ loaded, total, rate }) => {
          if (total < 256 * 1024) {
            return;
          }
          const progress = Math.round((loaded / total) * 100);
          progressBar.classList.remove('d-none');
          progressBarInner.style.width = `${progress}%`;
          progressBarInner.textContent = `${prefix}: ${progress}% (${B2KB(
            loaded
          )}/${B2KB(total)} KB, ${B2KB(rate)} KB/s)`;
        };
        return progressHook;
      }

      async function fetchCloudData() {
        try {
          const response = await axios.get(
            `${redis.host}MGET/${redis.prefix}:clipboard:type/${redis.prefix}:clipboard:data.raw`,
            {
              responseType: 'blob',
              auth: { username: redis.username, password: redis.password },
              onDownloadProgress: generateProgressHook('Downloading'),
            }
          );
          progressBar.classList.add('d-none');
          const blob = response.data;
          // Parse Redis RESP data manually, not using a RESP parser library since we use a very simple and fixed format
          // The RESP spec for the data types we need:
          //    Arrays: *<number-of-elements>\r\n<element-1>...<element-n>
          //    Bulk strings: $<length>\r\n<data>\r\n
          // An example data: *2\r\n$5\r\nimage\r\n$500\r\n[image]\r\n
          // where [image] is image bytes with 500 length
          const text = await blob.text();
          if (text === '*2\r\n') {
            return { type: null, data: 'Clipboard empty' };
          }
          const first = text.indexOf('\r\n');
          const second = text.indexOf('\r\n', first + 1);
          const third = text.indexOf('\r\n', second + 1);
          const fourth = text.indexOf('\r\n', third + 1);
          const type = text.slice(second + 2, third);
          if (type === 'image') {
            return { type, data: blob.slice(fourth + 2, -2, 'image/png') };
          } else if (type === 'text') {
            return { type, data: await blob.slice(fourth + 2, -2).text() };
          } else {
            throw new Error(`unknown type ${type}`);
          }
        } catch (e) {
          return {
            type: null,
            data: `Failed to fetch data from cloud: ${e.message}, ${e.stack}`,
          };
        }
      }

      function showClipboard({ type, data }, container) {
        if (type === 'image') {
          const image = new Image();
          image.src = URL.createObjectURL(data);
          image.classList.add('shadow');
          container.replaceChildren(image);
        } else if (type === 'text') {
          const node = document.createElement('textarea');
          node.value = data;
          node.classList.add('form-control');
          node.rows = 5;
          node.readOnly = true;
          container.replaceChildren(node);
        } else {
          const node = document.createElement('p');
          node.innerText = data;
          node.style.color = 'red';
          container.replaceChildren(node);
        }
      }

      let local;
      let cloud;
      let redis;

      const localContainer = document.querySelector('#local');
      const cloudContainer = document.querySelector('#cloud');

      async function getAndShowLocalClipboard() {
        local = await readClipboard();
        showClipboard(local, localContainer);
      }

      async function getAndShowCloudClipboard() {
        cloud = await fetchCloudData();
        showClipboard(cloud, cloudContainer);
      }

      // Used to distinguish whether the published message is from self
      const identifier = (Math.random() + 1).toString(36).substring(2);

      const progressBar = document.querySelector('#progressBar');
      const progressBarInner = document.querySelector('#progressBarInner');
      async function pushToCloud() {
        // Get newest local clipboard data.
        // The local clipboard data can not be automatically updated
        // as user interacting is needed to read clipboard
        await getAndShowLocalClipboard();
        const { type, data } = local;
        log('Begin pushing to cloud');
        if (!['image', 'text'].includes(type)) {
          log(`Failed to push to cloud: unknown type ${type}`);
          return;
        }
        try {
          await axios.put(
            `${redis.host}MSET/${redis.prefix}:clipboard:type/${type}/${redis.prefix}:clipboard:data`,
            data,
            {
              auth: { username: redis.username, password: redis.password },
              onUploadProgress: generateProgressHook('Uploading'),
            }
          );
          // Publish the change only after successfully pushing data
          await axios.get(
            `${redis.host}PUBLISH/${redis.prefix}:clipboard/change-from-${identifier}`,
            { auth: { username: redis.username, password: redis.password } }
          );
          progressBar.classList.add('d-none');
        } catch (e) {
          log(`Failed to push to cloud: ${e.message}, ${e.stack}`);
          return;
        }
        log('Finish pushing to cloud');
        cloud = local;
        showClipboard(cloud, cloudContainer);
      }

      async function pullToLocal() {
        // `cloud` is already the newest data
        const { type, data } = cloud;
        log('Begin pulling to local');
        try {
          if (type === 'image') {
            await navigator.clipboard.write([
              new ClipboardItem({ 'image/png': data }),
            ]);
          } else if (type === 'text') {
            const blob = new Blob([data], { type: 'text/plain' });
            await navigator.clipboard.write([
              new ClipboardItem({ 'text/plain': blob }),
            ]);
          } else {
            log(`Failed to pull to local: unknown type ${type}`);
            return;
          }
        } catch (e) {
          log(`Failed to pull to local: ${e.message}, ${e.stack}`);
          return;
        }
        log('Finish pulling to local');
        local = cloud;
        showClipboard(local, localContainer);
      }

      function longPolling() {
        log('Start long polling connection');
        let previousLength = 0;
        axios
          .get(`${redis.host}SUBSCRIBE/${redis.prefix}:clipboard`, {
            auth: { username: redis.username, password: redis.password },
            onDownloadProgress: ({ event }) => {
              const currentText = event.currentTarget.responseText;
              const chunk = currentText.slice(previousLength);
              previousLength = currentText.length;
              if (!chunk.includes(identifier) && chunk.includes('"message"')) {
                // Don't respond to updates from self to save a network request
                log('Change detected for cloud clipboard, updating');
                getAndShowCloudClipboard();
              }
            },
          })
          .catch(() => {
            // Restart the long polling
            longPolling();
          });
      }

      window.addEventListener('DOMContentLoaded', async () => {
        const storage = localStorage.getItem('redis');
        if (storage === null) {
          redis = {
            host: 'https://example.com/',
            prefix: 'prefix',
            username: 'username',
            password: 'password',
          };
          log('Redis info not found in local storage');
        } else {
          redis = JSON.parse(storage);
          log('Load redis info from local storage');
        }
        redisContainer.value = JSON.stringify(redis, null, 4);

        redisContainer.addEventListener('input', () => {
          redis = JSON.parse(redisContainer.value);
          localStorage.setItem('redis', redisContainer.value);
          log('Redis info changed');
        });

        getAndShowLocalClipboard();
        getAndShowCloudClipboard();
        longPolling();
      });
    </script>
  </body>
</html>
